<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rotation Matrix</title>
    <link href="/2024/09/05/Rotation-Matrix/"/>
    <url>/2024/09/05/Rotation-Matrix/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="性质和结论">性质和结论</h2><p><strong>从B frame相对于A frame的旋转矩阵的转置即为A frame相对于Bframe的旋转矩阵，同时等于其逆矩阵：</strong> <spanclass="math display">\[^{A}_{B}R = ^{B}_{A}A^{T}=^{B}_{A}A^{-1}\]</span><strong>旋转矩阵可以将一个点(P)从一个frame(B)变换到另一个frame(A)：</strong><span class="math display">\[^{A}P=^{A}_{B}R \cdot ^{B}P\]</span><strong>用坐标轴绕参考坐标系旋转角度来确定旋转矩阵：</strong> <spanclass="math display">\[R_{Z_{A}}({\theta})=\left[\begin{matrix}cos{\theta} &amp; -sin\theta &amp; 0 \\ sin{\theta} &amp; cos{\theta}&amp; 0 \\ 0 &amp; 0 &amp; 1 \end{matrix}\right]=\left[\begin{matrix}c{\theta} &amp; -s\theta &amp; 0 \\ s{\theta} &amp; c{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \end{matrix}\right]\]</span> <spanclass="math display">\[R_{X_{A}}({\theta})=\left[\begin{matrix} 1 &amp;0 &amp; 0 \\ 0 &amp; cos{\theta} &amp; -sin{\theta} \\ 0 &amp;sin{\theta} &amp; cos{\theta} \end{matrix}\right]=\left[\begin{matrix} 1&amp; 0 &amp; 0 \\ 0 &amp; c{\theta} &amp; -s{\theta} \\ 0 &amp;s{\theta} &amp; c{\theta} \end{matrix}\right]\]</span> <spanclass="math display">\[R_{Y_{A}}({\theta})=\left[\begin{matrix}cos{\theta} &amp; 0 &amp; sin{\theta} \\ 0 &amp; 1 &amp; 0 \\-sin{\theta} &amp; 0 &amp; cos{\theta}\end{matrix}\right]=\left[\begin{matrix} c{\theta} &amp; 0 &amp;s{\theta} \\ 0 &amp; 1 &amp; 0 \\ -s{\theta} &amp; 0 &amp; c{\theta}\end{matrix}\right]\]</span> <em>A表示Aframe，参考坐标系，即世界坐标系，B表示Bodyframe，本地坐标系，即物体坐标系。</em></p><p><strong>描述一个frame(B)相对另一个frame(A)的姿态：</strong> <spanclass="math display">\[^{A}_{B}R=\left[\begin{matrix} | &amp; | &amp; |\\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} \\ | &amp; | &amp; |\end{matrix}\right]\]</span> <em>其中<spanclass="math inline">\(^{A}X_{B}\)</span>，<spanclass="math inline">\(^{A}Y_{B}\)</span>，<spanclass="math inline">\(^{A}Z_{B}\)</span>分别代表B frame各坐标轴在Aframe投影的列向量。</em></p><h2 id="fixed-angles">Fixed Angles</h2><p><strong>针对空间中固定的坐标系XYZ进行旋转操作：</strong> <spanclass="math display">\[^{A}_{B}R_{XYZ}(\gamma,\beta,\alpha)=R_{Z}(\alpha)R_{Y}(\beta)R_{X}(\gamma)\]</span><span class="math display">\[=\left[\begin{matrix} c{\alpha} &amp;-s\alpha &amp; 0 \\ s{\alpha} &amp; c{\alpha} &amp; 0 \\ 0 &amp; 0 &amp;1 \end{matrix}\right]\left[\begin{matrix} c{\beta} &amp; 0 &amp;s{\beta} \\ 0 &amp; 1 &amp; 0 \\ -s{\beta} &amp; 0 &amp; c{\beta}\end{matrix}\right]\left[\begin{matrix} 1 &amp; 0 &amp; 0 \\ 0 &amp;c{\gamma} &amp; -s{\gamma} \\ 0 &amp; s{\gamma} &amp; c{\gamma}\end{matrix}\right]\]</span> <spanclass="math display">\[=\left[\begin{matrix}c{\alpha}c{\beta} &amp;c{\alpha}s{\beta}s{\gamma}-s{\alpha}c{\gamma} &amp;c{\alpha}s{\beta}c{\gamma}+s{\alpha}s{\gamma} \\ s{\alpha}c{\beta} &amp;s{\alpha}s{\beta}s{\gamma}+c{\alpha}c{\gamma} &amp;s{\alpha}s{\beta}c{\gamma}-c{\alpha}s{\gamma}  \\-s{\beta} &amp;c{\beta}s{\gamma} &amp;c{\beta}c{\gamma}\end{matrix}\right]=\left[\begin{matrix}r_{11} &amp;r_{12} &amp; r_{13} \\ r_{21} &amp; r_{22} &amp; r_{23} \\ r_{31} &amp;r_{32} &amp; r_{33}\end{matrix}\right]\]</span></p><p><em>先转的放在后面，转动的顺序（左乘）是不能互换的。</em></p><p><strong>通过R推算Angles：</strong> <spanclass="math display">\[^{A}_{B}R_{XYZ}(\gamma,\beta,\alpha)=\left[\begin{matrix}c{\alpha}c{\beta}&amp; c{\alpha}s{\beta}s{\gamma}-s{\alpha}c{\gamma} &amp;c{\alpha}s{\beta}c{\gamma}+s{\alpha}s{\gamma} \\ s{\alpha}c{\beta} &amp;s{\alpha}s{\beta}s{\gamma}+c{\alpha}c{\gamma} &amp;s{\alpha}s{\beta}c{\gamma}-c{\alpha}s{\gamma}  \\-s{\beta} &amp;c{\beta}s{\gamma} &amp;c{\beta}c{\gamma}\end{matrix}\right]=\left[\begin{matrix}r_{11} &amp;r_{12} &amp; r_{13} \\ r_{21} &amp; r_{22} &amp; r_{23} \\ r_{31} &amp;r_{32} &amp; r_{33}\end{matrix}\right]\]</span> <spanclass="math inline">\(if\space{\beta} \neq 90^{\circ}\)</span> <spanclass="math display">\[\beta=Atan2(-r_{31},\sqrt{r_{11}^2+r_{21}^2})\]</span><spanclass="math display">\[\alpha=Atan2(\frac{r_{21}}{c{\beta}},\frac{r_{11}}{c{\beta}})\]</span><spanclass="math display">\[\gamma=Atan2(\frac{r_{32}}{c{\beta}},\frac{r_{33}}{c{\beta}})\]</span><span class="math inline">\(if \space \beta=90^{\circ}\)</span> <spanclass="math display">\[\alpha=0^{\circ}\]</span> <spanclass="math display">\[\gamma=Atan2(r_{12},r_{22})\]</span> <spanclass="math inline">\(if \space \beta=-90^{\circ}\)</span> <spanclass="math display">\[\alpha=0^{\circ}\]</span> <spanclass="math display">\[\gamma=-Atan2(r_{12},r_{22})\]</span></p><h2 id="euler-angles">Euler Angles</h2><p><strong>Z-Y-X</strong> <spanclass="math display">\[^{A}_{B}R_{Z^{&#39;}Y^{&#39;}X^{&#39;}}(\alpha,\beta,\gamma)=^{A}_{B^{&#39;}}R^{B^{&#39;}}_{B^{&#39;&#39;}}R^{B^{&#39;&#39;}}_{B}R=R_{Z^{&#39;}}(\alpha)R_{Y^{&#39;}}(\beta)R_{X^{&#39;}}(\gamma)\]</span><em>先转的放在前面，转动的顺序（左乘）是不能互换的。</em> <em>对FixedAngle以XYZ的顺序转动，相当于对Euler Angle以ZYX的顺序转动。</em><em>Euler Angle的正转和Fixed Angle的反转会得到相同的解。</em></p><h2 id="刚体状态的表达">刚体状态的表达</h2><p><strong>Homogeneous transformation matrix (4x4):</strong> <spanclass="math display">\[^{A}_{B}T=\left[\begin{matrix}^{A}_{B}R_{3\times3}&amp; ^{A}P_{B_{org}3\times1} \\ 0_{1\times3} &amp;1\end{matrix}\right]\]</span> <spanclass="math display">\[=\left[\begin{matrix} | &amp; | &amp; | &amp; |\\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} &amp; P_{B_{org}} \\ |&amp; | &amp; | &amp; | \\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span><em>左上角为旋转矩阵，右上角为移动状态。</em></p><p><strong>移动和转动复合运算：</strong> <spanclass="math display">\[^{A}P_{3\times1}=^{A}_{B}R^{B}P_{3\times1}+^{A}P_{B_{org}3\times1}\]</span><span class="math display">\[\left[\begin{matrix}^{A}P \\1\end{matrix}\right]=^{A}_{B}T\left[\begin{matrix}^{B}P \\1\end{matrix}\right]\]</span></p><p><strong>可连续操作：</strong> <spanclass="math display">\[^{A}_{B}T=^{A}_{C}T^{C}_{D}T^{D}_{B}T\]</span><em>"sequential transformation"</em></p><p><strong>Mapping and Operator:</strong></p><p>transformationmatrix既有Mapping（把向量从一个frame转换到另一个frame下来看）的功能也可当作Operator对向量（或点）进行移动或旋转（在同一个frame）。</p><p><span class="math display">\[\left[\begin{matrix}^{A}P_2 \\1\end{matrix}\right]=T\left[\begin{matrix}^{A}P_1 \\1\end{matrix}\right]\]</span></p><h2 id="homogeneous-transformation-matrix的三种用法">Homogeneoustransformation matrix的三种用法</h2><ol type="1"><li>描述一个frame（相对于另一个frame）的空间状态。 <spanclass="math display">\[^{A}_{B}T=\left[\begin{matrix} | &amp; | &amp; |&amp; | \\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} &amp; P_{B_{org}}\\ | &amp; | &amp; | &amp; | \\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></li><li>将point由某一个frame的表达转换到另一个frame来表达。 <spanclass="math display">\[\left[\begin{matrix}^{A}P \\1\end{matrix}\right]=^{A}_{B}T\left[\begin{matrix}^{B}P \\1\end{matrix}\right]\]</span></li><li>将point(vector)在同一个frame中进行移动和转动。 <spanclass="math display">\[\left[\begin{matrix}^{A}P_2 \\1\end{matrix}\right]=T\left[\begin{matrix}^{A}P_1 \\1\end{matrix}\right]\]</span></li></ol><h2 id="transformation-matrix运算">Transformation Matrix运算</h2><p><strong>逆矩阵：</strong></p><p><spanclass="math display">\[^{A}_{B}T^{B}_{A}T=^{A}_{B}T^{A}_{B}T^{-1}=I_{4\times4}\]</span></p><p><spanclass="math display">\[^{A}_{B}T^{-1}=\left[\begin{matrix}^{A}_{B}R^{T}&amp; -^{A}_{B}{R^{T}}^{A}P_{B_{org}} \\ 0_{1\times3} &amp;1\end{matrix}\right]\]</span> <strong>连续运算法则：</strong></p><ol type="1"><li>{B}对{A}的转轴旋转：用"premultiply"，先转的放在后面</li><li>{B}对{B}自身的转轴旋转：用"postmultiply"，先转的放在前面</li></ol><h2 id="links">links</h2><p><a href="https://www.coursera.org/learn/robotics1">機器人學一(Robotics (1))</a></p>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CLF-CBF</title>
    <link href="/2024/09/04/CLF-CBF/"/>
    <url>/2024/09/04/CLF-CBF/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2id="动态控制仿射系统dynamics-control-affine-system">1.动态控制仿射系统(DynamicsControl Affine System)</h2><p>对于<span class="math inline">\(\dot{x} =F(t,x,u)\)</span>，其中系统状态<spanclass="math inline">\(x\in{\mathbb{R}^n}\)</span>，系统输入<spanclass="math inline">\(u \in{\mathbb{R}^m}\)</span>，如果<spanclass="math inline">\(F\)</span>对于<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(u\)</span>是Lipschitz连续的，时间<spanclass="math inline">\(t\)</span>是piecewise连续的，那么在给定的初始条件<spanclass="math inline">\(x_0\)</span>下，轨迹<spanclass="math inline">\(x(t)\)</span>是存在并且unique的。</p><p>一般写成如下形式：</p><p><span class="math display">\[\dot{x} = f(x) + g(x)u\]</span></p><p>其中<spanclass="math inline">\(f:\mathbb{R}^n\rightarrow{\mathbb{R}^n},g:\mathbb{R}^n\rightarrow{\mathbb{R}^{n*m}}\)</span>，<spanclass="math inline">\(x\)</span>是Lipschitz连续，<spanclass="math inline">\(x_e = 0\)</span>。</p><h2 id="clfcontrol-lyapunov-function">2.CLF(Control LyapunovFunction)</h2><p>Lyapunove Function数学定义如下：</p><p><span class="math display">\[V(x)\]</span> <spanclass="math display">\[s.t. V(x_e) = 0, V(x) &gt; 0 \ for \ x \neqx_e\]</span> <span class="math display">\[\dot{V(x)} = \frac{\partialV}{\partial x}f(x) &lt; 0 \ for \ x \neq x_e\]</span></p><p><spanclass="math inline">\(V(x)\)</span>是定义的Lyapunov函数，下面的是约束条件，当满足上述两个约束时，我们可以认为x渐近稳定。</p><p>将输入<span class="math inline">\(u\)</span>引入到LyapunoveFunction，得到新的方程。 使<spanclass="math inline">\(V(x):\mathbb{R}^n\rightarrow{\mathbb{R}}\)</span>是连续Differential函数，如果存在一个常数<spanclass="math inline">\(c&gt;0\)</span>使得<spanclass="math inline">\(V(x)\)</span>满足如下条件，那么<spanclass="math inline">\(V(x)\)</span>就是一个关于<spanclass="math inline">\(x\)</span>的Control Lyapunov Function。</p><p><span class="math inline">\(1)\ \Omega := \{x\in{\mathbb{R}^n}:V(x)\le{c}\}\)</span>，<spanclass="math inline">\(V(x)\)</span>是有界的</p><p><span class="math inline">\(2)\ V(x)&gt;0\)</span>，对于所有的<spanclass="math inline">\(s\in{R^n}\backslash \{x_e\}\)</span>，<spanclass="math inline">\(V(e_e)=0\)</span></p><p><span class="math inline">\(3)\inf_{u\in{U}}\dot{V}(x,u)&lt;0\)</span>，对于所有的<spanclass="math inline">\(x\in{\Omega_c}\backslash\{x_e\}\)</span></p><p>为了简化<spanclass="math inline">\(\dot{V}(x,u)\)</span>的表达，用Lie括号描述：</p><p><span class="math display">\[\dot{V}(x,u) = \nabla{V}(x) * \dot{x} =\nabla{V}(x) * f(x) + \nabla{V}(x) * g(x)*u = L_fV(x) +L_gV(x)u\]</span> <spanclass="math display">\[(L_pq(x):=\nabla{q(x)}*p(x))\]</span></p><p>CLF保证系统最终会稳定，但不能确定多快才能稳定，这时候引入指数稳定CLF(ESCLF)。</p><p>如果存在常数<span class="math inline">\(\lambda &gt;0\)</span>使得<span class="math inline">\(inf_{u\in{U}}\dot{V}(x,u)+{\lambda}{V(x)}\le0\)</span> ，那么<spanclass="math inline">\(V(x)\)</span>就是ESCLF。</p><p><img src="/img/CLF-CBF/ESCLF.png" /></p><h2 id="clf-qp">3.CLF-QP</h2><p>将CLF转化为QP问题，搜索满足CLF-QP问题的输入u。</p><p><span class="math display">\[argmin\  (u-u_ref)^{T}{H(u-u_ref)}+p\delta^2\]</span> <spanclass="math display">\[subject\ to :\L_fV(x)+L_gV(x)u+\lambda{V(x)}\le{\delta}\]</span></p><p>其中<span class="math inline">\(\delta\)</span>是松弛变量，<spanclass="math inline">\(p\)</span>是惩罚因子，设置松弛变量的目的是在实际搜索中，较难找到一个合适的解，增加松弛变量后会放松CLF条件，在允许的情况下不满足CLF约束，但获得一个解。</p><p>另外，这里的H是Hassian矩阵，表示二次项系数，将<spanclass="math inline">\((u-u_ref)^{T}{H(u-u_ref)}\)</span>理解为二次的cost函数(或者能量函数？)，是人为构建的，二次保证解的u的输入使系统收敛较快。</p><h2 id="cbf">4.CBF</h2><p>CLF约束确保系统渐趋稳定，而CBF的作用是确保系统安全，使系统处于规定的安全集合约束内。</p><pre><code class="hljs">//TODO:补充CBF原理</code></pre><p>当<span class="math inline">\(B(x):\mathbb{R}^n \rightarrow\mathbb{R}\)</span>是连续可微的，零超水平集(zero-superlevel)为<spanclass="math inline">\(C\)</span>，<spanclass="math inline">\(C=\{x|B(x)\ge0\}\)</span>，对于所有<spanclass="math inline">\(x\in{\partial{C}}\)</span>，<spanclass="math inline">\(\nabla{B(x)\ne0}\)</span>，如果存在一个扩展<spanclass="math inline">\(Class \ K_\infty\)</span>函数<spanclass="math inline">\(\alpha\)</span>（工程中一般使用正常数和<spanclass="math inline">\(B(x)\)</span>的线性组合获取，如：<spanclass="math inline">\(\gamma{B(x)},\gamma&gt;0\)</span>），存在一个集合<spanclass="math inline">\(D\subset{\mathbb{R}^n}\)</span>，使得<spanclass="math inline">\(C\subset{D}\)</span>满足：</p><p><spanclass="math display">\[sup_{u\in{U}}[L_f{B(x)}+L_g{B(x)}u]+\alpha({B(x)})\ge0\]</span></p><p>那么对于所有<span class="math inline">\(x\in{D}\)</span>，<spanclass="math inline">\(B(x)\)</span>是一个CBF。</p><p><img src="/img/CLF-CBF/CBF.png" /></p><h2 id="clf-cbf-qp">5.CLF-CBF-QP</h2><p>将CLF和CBF都转化为QP问题的约束条件，其中CLF保证控制器稳定，CBF保证控制满足安全条件。</p><p><span class="math display">\[argmin\  (u-u_ref)^{T}{H(u-u_ref)}+p\delta^2\]</span> <spanclass="math display">\[subject\ to :\]</span> <spanclass="math display">\[\L_fV(x)+L_gV(x)u+\lambda{V(x)}\le{\delta}\]</span> <spanclass="math display">\[L_f{B(x)}+L_g{B(x)}u]+\gamma{B(x)}\ge0\]</span></p><h2 id="links">links</h2><ul><li><em><ahref="https://zhuanlan.zhihu.com/p/568328445">根据自适应巡航系统(ACC)来理解CBF(ControlBarrier Function)-入门知识</a></em><br /></li><li><em><a href="https://zhuanlan.zhihu.com/p/277326421">CLF-CBFController</a></em><br /></li><li><em><ahref="https://github.com/HybridRobotics/CBF-CLF-Helper">HybridRobotics/CBF-CLF-Helper</a></em><br /></li><li><em><a href="https://www.youtube.com/watch?v=_Tkn_Hzo4AA">Jason Choi-- Introduction to Control Lyapunov Functions and Control BarrierFunctions</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反步控制</title>
    <link href="/2024/09/04/%E5%8F%8D%E6%AD%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/09/04/%E5%8F%8D%E6%AD%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="物理模型">1.1 物理模型 ###</h2><p>令期望轨迹为<span class="math inline">\(sint\)</span>曲线：<br /><span class="math display">\[x_d = \sin{t}\]</span> <spanclass="math display">\[\dot{x_d} = \cos{t}\]</span></p><p>写出状态方程：<br /><span class="math display">\[\dot{x_1} = x_2 + f_1(x_1)\]</span> <spanclass="math display">\[\dot{x_2} = u + f_2(x_1,x_2) = u + \frac{(M * g *l)}{J} * \sin{x_1} - \frac{D}{J} * x_2\]</span></p><p><span class="math display">\[f_1(x_1) = 0\]</span> <spanclass="math display">\[f_2(x_1,x_2) = \frac{(M * g * l)}{J} * \sin{x_1}- \frac{D}{J} * x_2\]</span>其中第一项为重力对系统的影响，第二项为摩擦力对系统的影响。</p><p><em>其中M为质量，g为重力加速度，l为臂长，J为转动惯量，D为阻尼系数。</em><em><span class="math inline">\(\dot{x_1}\)</span>为角速度，<spanclass="math inline">\(\dot{x_2}\)</span>为角加速度，<spanclass="math inline">\(x_1\)</span>为角度，<spanclass="math inline">\(x_2\)</span>为角速度。</em></p><h2 id="知识补充">1.2 知识补充</h2><p>力矩<span class="math inline">\(M = |F| * |r| *\sin{\varphi}\)</span>力矩除以转动惯量可以描述一个物体收到的外部力矩对其角加速度的影响。阻尼系数除以转动惯量乘以角速度描述了在转动运动中由阻尼产生的转动摩擦力的效应。这个物理量通常被称为阻尼比。</p><p><em>*部分解释来自chatgpt</em></p><h2 id="反步控制">2.1 反步控制</h2><p>构造误差 <span class="math display">\[e_1 = x_1 - x_d\]</span> <spanclass="math display">\[e_2 = x_2 - \alpha_1\]</span> 其中<spanclass="math inline">\(\alpha_1\)</span>为虚拟控制律，即中间状态的控制量。</p><p>构造Lyapunov函数 <span class="math display">\[V_1 =\frac{1}{2}{e_1}^2\]</span> <span class="math display">\[V_2 =\frac{1}{2}{e_1}^2 + \frac{1}{2}{e_2}^2\]</span></p><p>由Lyapunov方法可知，需令<spanclass="math inline">\(\dot{V_1}\)</span> ,<spanclass="math inline">\(\dot{V_2}\)</span>负定使得系统渐趋稳定。</p><p><span class="math display">\[\dot{V_1} = {e_1}\dot{e_1} ={e_1}(\dot{x_1} - \dot{x_d}) = {e_1}(x_2 + f_1(x_1) -\cos{t})\]</span></p><p>故令<span class="math inline">\(\alpha_1 = \cos{t} - e_1 -f_1(x_1)\)</span>，注意此时<spanclass="math inline">\(\alpha_1\)</span>为虚拟控制律，<spanclass="math inline">\(x_2\)</span>为实际控制</p><p><span class="math display">\[\dot{V_1} = {e_1}\dot{e_1} ={e_1}(\dot{x_1} - \dot{x_d})\]</span> <span class="math display">\[ ={e_1}(x_2 + f_1(x_1) - \cos{t}) = {e_1}(e_2 + \alpha_1 + f_1(x_1) -\cos{t}) = {e_1}(e_2 - e_1)\]</span></p><p><span class="math display">\[\dot{e_2} = \dot{x_2} - \dot{\alpha_1} =u + f_2(x_1,x_2) - \dot{\alpha_1}\]</span></p><p><span class="math display">\[\dot{V_2} = e_1(e_2 - e_1) +{e_2}\dot{e_2} = -{e_1}^2 + {e_2}({e_1} + \dot{e_2})\]</span></p><p>需令<span class="math inline">\(\dot{V_2}\)</span>负定，令<spanclass="math inline">\(e_1 + \dot{e_2} = -e_2\)</span>即可，此时<spanclass="math inline">\(\dot{V_2} = -{e_1}^2 - {e_2}^2\)</span>负定 代入得<span class="math inline">\(e_1 + u + f_2(x_1,x_2) - \alpha_1 =-e_2\)</span> 得到最终控制量<span class="math inline">\(u = -e_1 - e_2 -f_2(x_1,x_2) + \dot{\alpha_1}\)</span></p><p>上面得到 <span class="math display">\[f_1(x_1) = 0\]</span> <spanclass="math display">\[f_2(x_1,x_2) = \frac{(M * g * l)}{J} * \sin{x_1}- \frac{D}{J} * x_2\]</span></p><p>所以<span class="math display">\[u = -e_1 - e_2 + \dot{\alpha_1} -(\frac{(M * g * l)}{J} * \sin{x_1} - \frac{D}{J} * x_2)\]</span></p><h2 id="links">links</h2><ul><li><em><ahref="https://haosutopia.github.io/2018/01/Backstepping-01/">Backstepping（反步控制）</a></em></li><li><em><ahref="https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%8E%A8%E6%8E%A7%E5%88%B6">wiki反推控制</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>裂痕</title>
    <link href="/2024/09/03/%E8%A3%82%E7%97%95/"/>
    <url>/2024/09/03/%E8%A3%82%E7%97%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><center>裂痕</center><center>边缘纹路生长，</center><center>哭泣的笑容，</center><center>过去的完整再无有几分存在。</center><center>爱或未来，</center><center>自甘地遗忘。</center><center>燃烧一盎司灵魂也无法弥补这急转隔断，</center><center>都不足一千公里的时间长。</center><center>笨拙的花张口结舌，</center><center>眼泪流淌。</center><center>几缕薄影倏忽而过，</center><center>哀荣四泻。</center><center>破碎，</center><center>月和目光。</center><center>源头是廉价的情感理想，</center><center>尾流入地海。</center><center>二到一到二，</center><center>无到有到无。</center><center>过度或翼翼滋生裂隙，</center><center>自产怒火惊雷，</center><center>静静撕咬。</center><center>曾是永远完整永远一起，</center><center>无有输赢，</center><center>而今却是谢幕时光。</center><center>痛苦急速转换，</center><center>一道无形的裂痕悄然而生，</center><center>自此疾驰。</center><center>幻想和秋风，</center><center>由我亲手斩断，</center><center>显现的裂痕，</center><center>存于你我各自世界之间</center>]]></content>
    
    
    <categories>
      
      <category>发电</category>
      
    </categories>
    
    
    <tags>
      
      <tag>poem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
