<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>impedance control</title>
    <link href="/2024/09/08/impedance-control/"/>
    <url>/2024/09/08/impedance-control/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="代码">代码</h2><p>根据论文：<ahref="https://www.sciencedirect.com/science/article/abs/pii/S0019057822000726"><em>High-ordercontrol barrier functions-based impedance control of a roboticmanipulator with time-varying output constraints</em></a>的阻抗控制部分编写的代码，不同于visp_ros阻抗控制的官方例程。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs zephir">#include &lt;visp3/gui/vpPlot.h&gt;<br>#include <span class="hljs-string">&quot;../control_proj/base_tool_func.h&quot;</span><br>vpPlot* CreatePlot();<br>void DestroyPlot(vpPlot* plotter);<br><span class="hljs-keyword">int</span> main( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv )&#123;<br>    symc::OptSettings opt_settings;<br>    <span class="hljs-keyword">if</span>(symc::ArgHandle(argc, argv, opt_settings) == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>    &#125;<br><br>    vpROSRobotFrankaCoppeliasim robot;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        symc::SignalManager::RegisterSignalHandlers();<br>        <span class="hljs-comment">//init ros node</span><br>        ros::init( argc, argv, <span class="hljs-string">&quot;visp_ros&quot;</span>, ros::init_options::NoSigintHandler );<br>        ros::NodeHandlePtr n = boost::make_shared&lt; ros::NodeHandle &gt;();<br>        ros::Rate loop_rate(<span class="hljs-number">1000</span>);<br>        ros::spinOnce();<br>        robot.setVerbose( opt_settings.verbose);<br>        robot.connect();<br>        symc::ResetSimulation(robot);<br>        vpColVector q_init( &#123; <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">-45</span> ), <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">-135</span> ), <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">90</span> ), vpMath::rad( <span class="hljs-number">45</span> ) &#125; );<br>        symc::InitRobotPosition(robot, q_init);<br>        <span class="hljs-comment">//draw</span><br>        vpPlot *plotter = CreatePlot();<br>        vpColVector q(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>);<br>        robot.getPosition(vpRobot::JOINT_STATE, q);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Initial joint position: &quot;</span> &lt;&lt; q.t() &lt;&lt; std::endl;<br>        robot.setRobotState(vpRobot::STATE_FORCE_TORQUE_CONTROL);<br>        robot.setCoppeliasimSyncMode(opt_settings.coppeliasim_sync_mode);<br><br>        <span class="hljs-keyword">bool</span> should_quit  = <span class="hljs-keyword">false</span>;<br>        vpColVector  tau_d(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>), tau_cmd(<span class="hljs-number">7</span>, <span class="hljs-number">0</span>), F_tip(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>);<br>        vpColVector x_e(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>), dx_e(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>), x_d(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>), dx_d(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>), ddx_d(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>);<br>        vpColVector  x_xd(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>), pose_err(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>), p_x(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>), p_y(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        vpMatrix   Bd(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>), Kd(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>);<br>        Bd.eye();<br>        Kd.eye();<br>        vpHomogeneousMatrix bTe, fMe_d;<br>        <span class="hljs-comment">// initial pose</span><br>        fMe_d  = robot.get_fMe();<br>        <span class="hljs-comment">//tune</span><br>        Bd = <span class="hljs-number">20</span>*Bd;<br>        Kd = <span class="hljs-number">250</span>*Kd;<br>        symc::SystemInfo sys_info;<br>        symc::RobotInfo robot_info;<br>        <span class="hljs-keyword">while</span> (!should_quit &amp;&amp; !symc::SignalManager::ShouldExit())&#123;<br>            sys_info.UpdateTime(robot);<br>            robot_info.Update(robot, sys_info.dt_);<br>            <br>            <span class="hljs-comment">// Compute Cartesian trajectories</span><br>            fMe_d[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] = robot_info.fMe0_[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>] + (sys_info.is_trajectory_started_ ? (<span class="hljs-number">0.15</span>*sin(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>);<br>            fMe_d[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = robot_info.fMe0_[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + (sys_info.is_trajectory_started_ ? (<span class="hljs-number">0.15</span>*cos(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// fMe_d[2][3] = bTe0[2][3]  + ( start_trajectory ? ( 0.15*sin(fre*( time_cur - time_start_trajectory  ) )) : 0) ;</span><br>            x_d = (vpColVector)vpPoseVector(fMe_d);<br>            dx_d[<span class="hljs-number">0</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">0.15</span>*<span class="hljs-number">2</span>*M_PI*cos(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>);<br>            dx_d[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-0.15</span>*<span class="hljs-number">2</span>*M_PI*sin(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// dx_d[2] = ( start_trajectory ? (fre*0.15*cos(fre*( time_cur - time_start_trajectory  ) ) ) : 0) ;</span><br>            ddx_d[<span class="hljs-number">0</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-0.15</span>*<span class="hljs-number">2</span>*M_PI*<span class="hljs-number">2</span>*M_PI*sin(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_ ))) : <span class="hljs-number">0</span>);<br>            ddx_d[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-0.15</span>*<span class="hljs-number">2</span>*M_PI*<span class="hljs-number">2</span>*M_PI*cos(<span class="hljs-number">2</span>*M_PI*(sys_info.time_current_ - sys_info.time_start_trajectory_ ))) : <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// ddx_d[2] = ( start_trajectory ? (-fre*fre*0.15*sin(fre*( time_cur - time_start_trajectory  ) ) ) : 0) ;</span><br><br>            bTe = robot.get_fMe();<br>            x_e = (vpColVector)vpPoseVector(bTe*fMe_d.inverse() ); <span class="hljs-comment">// x - xd</span><br>            dx_e = robot_info.Ja_*robot_info.q_dot_ - dx_d ; <span class="hljs-comment">// x_dot - x_dot_d</span><br>            F_tip = robot_info.M_x_*(-Kd*(x_e)-Bd*(dx_e)+ddx_d) + robot_info.C_x_*robot_info.x_dot_;<br>            tau_d = robot_info.Ja_.t()*F_tip;<br><br><br>            tau_cmd = tau_d*(<span class="hljs-number">1</span>-std::exp(<span class="hljs-number">-4</span>*(sys_info.time_current_ - sys_info.time_start_trajectory_)));<br>            robot.setForceTorque(vpRobot::JOINT_STATE, tau_cmd);<br>            <br>            <br>            <span class="hljs-keyword">if</span>(opt_settings.verbose)<br>            &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;dt: &quot;</span> &lt;&lt; sys_info.dt_ &lt;&lt; std::endl;<br>            &#125;<br>            <br>            <span class="hljs-comment">//draw plot</span><br>            x_xd[<span class="hljs-number">0</span>] = robot_info.x_[<span class="hljs-number">0</span>];<br>            x_xd[<span class="hljs-number">1</span>] = x_d[<span class="hljs-number">0</span>];<br>            x_xd[<span class="hljs-number">2</span>] = robot_info.x_[<span class="hljs-number">1</span>];<br>            x_xd[<span class="hljs-number">3</span>] =x_d[<span class="hljs-number">1</span>];<br>            x_xd[<span class="hljs-number">4</span>] = robot_info.x_[<span class="hljs-number">2</span>];<br>            x_xd[<span class="hljs-number">5</span>] = x_d[<span class="hljs-number">2</span>];<br>            pose_err[<span class="hljs-number">0</span>] = std::abs(x_d[<span class="hljs-number">0</span>]-robot_info.x_[<span class="hljs-number">0</span>]);<br>            pose_err[<span class="hljs-number">1</span>] = std::abs(x_d[<span class="hljs-number">1</span>]-robot_info.x_[<span class="hljs-number">1</span>]);<br>            pose_err[<span class="hljs-number">2</span>] = std::abs(x_d[<span class="hljs-number">2</span>]-robot_info.x_[<span class="hljs-number">2</span>]);<br>            pose_err[<span class="hljs-number">3</span>] = sqrt(x_e.extract(<span class="hljs-number">3</span>,<span class="hljs-number">3</span> ).sumSquare());<br>            p_x = robot_info.x_[<span class="hljs-number">0</span>];<br>            p_y = robot_info.x_[<span class="hljs-number">1</span>];<br>            plotter-&gt;plot(<span class="hljs-number">0</span>, sys_info.time_current_, x_xd);<br>            plotter-&gt;plot(<span class="hljs-number">1</span>, <span class="hljs-keyword">double</span>(robot_info.x_[<span class="hljs-number">0</span>]), p_y);<br>            plotter-&gt;plot(<span class="hljs-number">2</span>, sys_info.time_current_, robot_info.tau_);<br>            plotter-&gt;plot(<span class="hljs-number">3</span>, sys_info.time_current_, pose_err);<br><br>            <span class="hljs-comment">//exit by clicking right mouse button</span><br>            vpMouseButton::vpMouseButtonType button;<br>            <span class="hljs-keyword">if</span>(vpDisplay::getClick(plotter-&gt;I, button, <span class="hljs-keyword">false</span>))&#123;<br>                <span class="hljs-keyword">if</span>(button==vpMouseButton::button3)&#123;<br>                    should_quit = <span class="hljs-keyword">true</span>;<br>                    tau_cmd = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            robot.wait(sys_info.time_current_, <span class="hljs-number">0.001</span>);<br>        &#125;<br>        <span class="hljs-comment">//save data</span><br>        <span class="hljs-keyword">if</span>(opt_settings.save_data)&#123;<br>            plotter-&gt;saveData(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;impedance-control-position_desire.txt&quot;</span>, <span class="hljs-string">&quot;# &quot;</span> );<br>            plotter-&gt;saveData(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;impedance-control-x_y_position.txt&quot;</span>, <span class="hljs-string">&quot;# &quot;</span> );<br>            plotter-&gt;saveData(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;impedance-control-error.txt&quot;</span>, <span class="hljs-string">&quot;# &quot;</span> );<br>        &#125;<br>        DestroyPlot(plotter);<br>        symc::StopSimulation(robot);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( <span class="hljs-keyword">const</span> vpException &amp;e )&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ViSP exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;<br>        symc::StopSimulation(robot);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br>vpPlot* CreatePlot()&#123;<br>    vpPlot* plotter = nullptr;<br>    plotter = <span class="hljs-keyword">new</span> vpPlot(<span class="hljs-number">4</span>, <span class="hljs-number">800</span>, <span class="hljs-number">800</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;Real time curves plotter&quot;</span> );<br>    plotter-&gt;setTitle(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;x/xd y/yd z/zd[m]&quot;</span> );<br>    plotter-&gt;initGraph(<span class="hljs-number">0</span>, <span class="hljs-number">6</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;x&quot;</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;xd&quot;</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;y&quot;</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;yd&quot;</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;z&quot;</span> );<br>    plotter-&gt;setLegend(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;zd&quot;</span> );<br>    plotter-&gt;setTitle(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;x/y [m]&quot;</span> );<br>    plotter-&gt;initGraph(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> );<br>    plotter-&gt;setTitle(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Joint torques measure [Nm]&quot;</span> );<br>    plotter-&gt;initGraph(<span class="hljs-number">2</span>, <span class="hljs-number">7</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Tau1&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Tau2&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Tau3&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Tau4&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;Tau5&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Tau6&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Tau7&quot;</span> );<br>    plotter-&gt;setTitle( <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Cartesian EE pose error [m] &quot;</span> );<br>    plotter-&gt;initGraph( <span class="hljs-number">3</span>, <span class="hljs-number">4</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;e_x&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;e_y&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;e_z&quot;</span> );<br>    plotter-&gt;setLegend( <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;||e_o||&quot;</span> );<br><br>    <span class="hljs-keyword">return</span> plotter;<br>&#125;<br><br>void DestroyPlot(vpPlot* plotter)&#123;<br>    <span class="hljs-keyword">if</span> ( plotter != nullptr )<br>    &#123;<br>        delete plotter;<br>        plotter = nullptr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="推导">推导</h2><p>后面补充，好累。。。</p>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>impedance control with visp_ros</title>
    <link href="/2024/09/06/impedance-control-with-visp-ros/"/>
    <url>/2024/09/06/impedance-control-with-visp-ros/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="代码">代码</h2><p>先把代码贴上来，后面进行总结，同时结合chatgpt记录一下其中的数学原理。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;visp_ros/vpROSRobotFrankaCoppeliasim.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base_tool_func.h&quot;</span></span><br><br>symc::SystemInfo sys_info;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>&#123;<br>    symc::OptSettings opt_settings;<br>    <span class="hljs-keyword">if</span>(symc::<span class="hljs-built_in">ArgHandle</span>(argc, argv, opt_settings) == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>    &#125;<br>    symc::SignalManager::<span class="hljs-built_in">RegisterSignalHandlers</span>();<br>    vpROSRobotFrankaCoppeliasim robot;<br>    <span class="hljs-keyword">try</span>&#123;<br>        ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;visp_ros&quot;</span>, ros::init_options::NoSigintHandler);<br>        ros::NodeHandlePtr n = boost::<span class="hljs-built_in">make_shared</span>&lt;ros::NodeHandle&gt;();<br>        <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span></span>;<br>        ros::<span class="hljs-built_in">spinOnce</span>();<br>        robot.<span class="hljs-built_in">setVerbose</span>(opt_settings.verbose);<br>        robot.<span class="hljs-built_in">connect</span>();<br>        symc::<span class="hljs-built_in">ResetSimulation</span>(robot);<br><br>        <span class="hljs-function">vpColVector <span class="hljs-title">q_init</span><span class="hljs-params">( &#123; <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">-45</span> ), <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">-135</span> ), <span class="hljs-number">0</span>, vpMath::rad( <span class="hljs-number">90</span> ), vpMath::rad( <span class="hljs-number">45</span> ) &#125; )</span></span>;<br>        symc::<span class="hljs-built_in">InitRobotPosition</span>(robot, q_init);<br><br>        <span class="hljs-function">vpColVector <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// joint position</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">q_dot</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// joint velocity</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">x_error</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// position error in cartesian space</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">x_dot_error</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// velocity error in cartesian space</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">x_dot_desired</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// desired cartesian velocity</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">x_dot_dot_desired</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// desired cartesian acceleration</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// Coriolis and centrifugal forces</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// friction forces</span><br><br>        <span class="hljs-function">vpColVector <span class="hljs-title">tau0</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// initial joint torque</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">tau</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// joint torque</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">tau_desired</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// desired joint torque</span><br>        <span class="hljs-function">vpColVector <span class="hljs-title">tau_cmd</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// joint torque command</span><br><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">fJe</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// Jacobian matrix in operational frame</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">Ja</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// Jacobian matrix in world frame</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">Ja_dot</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// Jacobian matrix derivative</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">Ja_old</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// old Jacobian matrix</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// joint space inertia matrix in cartesian space</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">I7</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">// identity matrix</span><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">Ja_pinv_B_t</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">6</span>)</span></span>; <span class="hljs-comment">// pseudo-inverse of the Jacobian matrix multiplied by the inertia matrix</span><br>        I<span class="hljs-number">7.</span><span class="hljs-built_in">eye</span>();<br>        &#123;<br>            robot.<span class="hljs-built_in">getPosition</span>(vpRobot::JOINT_STATE, q);<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;Initial joint position: &quot;</span>&lt;&lt;q.<span class="hljs-built_in">t</span>()&lt;&lt;std::endl;<br>        &#125;<br>        robot.<span class="hljs-built_in">setRobotState</span>(vpRobot::STATE_FORCE_TORQUE_CONTROL);<br>        robot.<span class="hljs-built_in">setCoppeliasimSyncMode</span>(opt_settings.coppeliasim_sync_mode);<br><br>        vpHomogeneousMatrix fMed, fMed0, fMe;<br>        fMed = fMed0 = robot.<span class="hljs-built_in">get_fMe</span>(); <span class="hljs-comment">// get end-effector pose</span><br><br>        <span class="hljs-function">vpMatrix <span class="hljs-title">K</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)</span></span>;<br>        <span class="hljs-function">vpMatrix <span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)</span></span>;<br>        <span class="hljs-function">vpMatrix <span class="hljs-title">edVf</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>)</span></span>; <span class="hljs-comment">// rotation matrix from operational frame to world frame(linear velocity and angular velocity)</span><br><br>        <span class="hljs-type">double</span> wp = <span class="hljs-number">50.0</span>; <span class="hljs-comment">// position control gain</span><br>        <span class="hljs-type">double</span> wo = <span class="hljs-number">20.0</span>; <span class="hljs-comment">// orientation control gain</span><br><br>        K.<span class="hljs-built_in">diag</span>(&#123;wp*wp, wp*wp, wp*wp, wo*wo, wo*wo, wo*wo&#125;);<br>        D.<span class="hljs-built_in">diag</span>(&#123;<span class="hljs-number">2</span>*wp, <span class="hljs-number">2</span>*wp, <span class="hljs-number">2</span>*wp, <span class="hljs-number">2</span>*wo, <span class="hljs-number">2</span>*wo, <span class="hljs-number">2</span>*wo&#125;);<br>        <span class="hljs-type">double</span> mu = <span class="hljs-number">0.1</span>; <span class="hljs-comment">// friction coefficient</span><br><br>        std::cout&lt;&lt;<span class="hljs-string">&quot;--Init finished. Press ctrl c to exit--&quot;</span>&lt;&lt;std::endl;<br><br>        <span class="hljs-keyword">while</span>(!symc::SignalManager::<span class="hljs-built_in">ShouldExit</span>())&#123;<br>            robot.<span class="hljs-built_in">getPosition</span>(vpRobot::JOINT_STATE, q);<br>            robot.<span class="hljs-built_in">getVelocity</span>(vpRobot::JOINT_STATE, q_dot);<br>            robot.<span class="hljs-built_in">getMass</span>(B);<br>            robot.<span class="hljs-built_in">getCoriolis</span>(C);<br>            robot.<span class="hljs-built_in">getFriction</span>(F);<br>            robot.<span class="hljs-built_in">get_fJe</span>(fJe); <span class="hljs-comment">// get Jacobian matrix in operational frame</span><br>            robot.<span class="hljs-built_in">getForceTorque</span>(vpRobot::JOINT_STATE, tau);<br>            <br>            fMed[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = fMed0[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + (sys_info.is_trajectory_started_ ? ( <span class="hljs-number">0.1</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span> );<br>            fMed[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = fMed0[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] - (sys_info.is_trajectory_started_ ? ( <span class="hljs-number">0.05</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>            x_dot_desired[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">0.1</span> * <span class="hljs-built_in">cos</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>            x_dot_desired[<span class="hljs-number">2</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">0.05</span> * <span class="hljs-built_in">cos</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br><br>            x_dot_dot_desired[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">0.1</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>            x_dot_dot_desired[<span class="hljs-number">2</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">0.05</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br><br>            edVf.<span class="hljs-built_in">insert</span>(fMed.<span class="hljs-built_in">getRotationMatrix</span>().<span class="hljs-built_in">t</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            edVf.<span class="hljs-built_in">insert</span>(fMed.<span class="hljs-built_in">getRotationMatrix</span>().<span class="hljs-built_in">t</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>            <br><br>            fMe = robot.<span class="hljs-built_in">get_fMe</span>(); <span class="hljs-comment">// get end-effector pose</span><br>            vpPoseVector pose_error = <span class="hljs-built_in">static_cast</span>&lt;vpPoseVector&gt;(fMed.<span class="hljs-built_in">inverse</span>() * fMe); <span class="hljs-comment">// get error in cartesian space</span><br>            <br><br>            vpMatrix La = symc::<span class="hljs-built_in">Ta</span>(pose_error); <span class="hljs-comment">// compute Lie algebra</span><br>            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>La*edVf is the matrix that can transform the velocity in operational frame to the velocity in world frame?</span><br>            Ja = La*edVf*fJe; <span class="hljs-comment">// compute Jacobian matrix in world frame</span><br>            <span class="hljs-keyword">if</span>(!symc::<span class="hljs-built_in">IsEqual</span>(sys_info.dt_, <span class="hljs-number">0</span>))&#123;<br>                Ja_dot = (Ja - Ja_old) / sys_info.dt_;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                Ja_dot = <span class="hljs-number">0</span>;<br>            &#125;<br>            Ja_old = Ja;<br>            <span class="hljs-comment">// weighted pseudo-inverse of the Jacobian matrix</span><br>            <span class="hljs-comment">// to optimize the control performance ?</span><br>            <span class="hljs-comment">// or to avoid singularity ?</span><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>the formula is from the paper:</span><br>            Ja_pinv_B_t = (Ja * B.<span class="hljs-built_in">inverseByCholesky</span>()*Ja.<span class="hljs-built_in">t</span>()).<span class="hljs-built_in">inverseByCholesky</span>()*Ja*B.<span class="hljs-built_in">inverseByCholesky</span>();<br>            <br>            <span class="hljs-comment">// compute desired joint torque</span><br>            x_error = <span class="hljs-built_in">static_cast</span>&lt;vpColVector&gt;(pose_error); <span class="hljs-comment">// compute error in cartesian space</span><br>            x_dot_error = La*edVf*(x_dot_desired - fJe*q_dot); <span class="hljs-comment">// compute velocity error in cartesian space</span><br>            <span class="hljs-comment">// formula: tau = M(q)*q_dot_dot + C(q,q_dot) + F(q_dot) + G(q)</span><br>            <span class="hljs-comment">// Ja.pseudoInverse is the inverse of the Jacobian matrix</span><br>            <span class="hljs-comment">// which can transform cartesian space to joint space</span><br>            vpMatrix control_law = (-K*(x_error)+D*(x_dot_error)-Ja_dot*q_dot + x_dot_dot_desired);<br>            tau_desired = B*Ja.<span class="hljs-built_in">pseudoInverse</span>()* control_law + C + F - (I7 - Ja.<span class="hljs-built_in">t</span>()*Ja_pinv_B_t)*B*q_dot*<span class="hljs-number">100</span>;<br>            <span class="hljs-comment">// tau_desired = B*Ja.pseudoInverse()* control_law + C + F;</span><br>            <span class="hljs-keyword">if</span>(sys_info.is_first_)&#123;<br>                tau0 = tau_desired;<br>            &#125;<br>            tau_cmd = tau_desired - tau0*std::<span class="hljs-built_in">exp</span>(-mu*sys_info.time_current_ - sys_info.time_start_trajectory_);<br><br>            <span class="hljs-comment">// apply the desired joint torque</span><br>            robot.<span class="hljs-built_in">setForceTorque</span>(vpRobot::JOINT_STATE, tau_cmd);<br><br>            <span class="hljs-keyword">if</span>(opt_settings.verbose)&#123;<br>                std::cout&lt;&lt;<span class="hljs-string">&quot;dt: &quot;</span>&lt;&lt;sys_info.dt_&lt;&lt;std::endl;<br>            &#125;<br>            robot.<span class="hljs-built_in">wait</span>(sys_info.time_current_, <span class="hljs-number">0.001</span>); <span class="hljs-comment">// Sync loop at 1000 Hz (1 ms)</span><br>            sys_info.<span class="hljs-built_in">UpdateTime</span>(robot);<br>        &#125;<br>        symc::<span class="hljs-built_in">StopSimulation</span>(robot);<br>    &#125;<span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> vpException&amp; e)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Catch an exception: &quot;</span>&lt;&lt;e.<span class="hljs-built_in">what</span>()&lt;&lt;std::endl;<br>        symc::<span class="hljs-built_in">StopSimulation</span>(robot);<br>        <span class="hljs-keyword">return</span> EXIT_FAILURE;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;--Exited--&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="总结及推导">总结及推导</h2><h3 id="说明">说明</h3><p>这里直接跳过不太重要的部分，从字面意思即可理解其作用，重点说明while循环内的内容。</p><ul><li><p>下面以base frame指代基坐标系（位姿），end-effectorframe指代末端执行器坐标系（位姿），因为Homogeneous TransformationMatrix既可以表示变换也可以表示位姿，所以后面就不特意说明是位姿还是变换操作了。</p></li><li><p>用task space(cartesianspace)指代任务空间（也就是笛卡尔空间），用jointspace指代关节空间。</p></li></ul><p>下面逐行进行解释。</p><h3 id="初始化">初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">robot.<span class="hljs-built_in">getPosition</span>(vpRobot::JOINT_STATE, q);<br>robot.<span class="hljs-built_in">getVelocity</span>(vpRobot::JOINT_STATE, q_dot);<br>robot.<span class="hljs-built_in">getMass</span>(B);<br>robot.<span class="hljs-built_in">getCoriolis</span>(C);<br>robot.<span class="hljs-built_in">getFriction</span>(F);<br>robot.<span class="hljs-built_in">get_fJe</span>(fJe);<br>robot.<span class="hljs-built_in">getForceTorque</span>(vpRobot::JOINT_STATE, tau);<br><br></code></pre></td></tr></table></figure><p>这里通过调用visp_ros的接口获取franka的信息，其中：<br />* <em>getMass()</em> 指获取质量矩阵(inertia matrix, 惯性矩阵)<br />* <em>getCoriolis()</em> 指获取科里奥利力矩阵<br />* <em>getFriction()</em> 指获取摩擦力矩阵<br />* <em>get_fJe()</em> 指获取雅可比矩阵(Jacobianmatrix)，注意这里是关节空间下的雅可比矩阵</p><p>其他根据字面意思理解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fMed[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = fMed0[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] + (sys_info.is_trajectory_started_ ? ( <span class="hljs-number">0.1</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span> );<br>fMed[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = fMed0[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] - (sys_info.is_trajectory_started_ ? ( <span class="hljs-number">0.05</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>x_dot_desired[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">0.1</span> * <span class="hljs-built_in">cos</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>x_dot_desired[<span class="hljs-number">2</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">0.05</span> * <span class="hljs-built_in">cos</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br><br>x_dot_dot_desired[<span class="hljs-number">1</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">-2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * <span class="hljs-number">0.1</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.3</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br>x_dot_dot_desired[<span class="hljs-number">2</span>] = (sys_info.is_trajectory_started_ ? (<span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * <span class="hljs-number">0.05</span> * <span class="hljs-built_in">sin</span>( <span class="hljs-number">2</span> * M_PI * <span class="hljs-number">0.6</span> * (sys_info.time_current_ - sys_info.time_start_trajectory_))) : <span class="hljs-number">0</span>) ;<br><br></code></pre></td></tr></table></figure><p>设定参考轨迹，也就是目标轨迹，fMed,fMed0均是<em>vpHomogeneousMatrix</em>类型fMed[4][4]的index先是行再是列，与矩阵表示习惯相同。<br />这里贴一下<em>vpHomogeneousMatrix</em>类型的部分源码注释：</p><p>The class provides a data structure for the homogeneous matrices aswell as a set of operations on these matrices.</p><p>The vpHomogeneousMatrix class is derived fromvpArray2D&lt;double&gt;.</p><p>An homogeneous matrix is 4x4 matrix defines as <spanclass="math display">\[\left[^a{\bf M}_b = \left(\begin{array}{cc}^a{\bf R}_b &amp; ^a{\bf t}_b \\{\bf 0}_{1\times 3} &amp; 1\end{array}\right)\right]\]</span><br />that defines the position of frame <em>b</em> in frame <em>a</em></p><p><span class="math inline">\(^a{R}_b\)</span> is a rotation matrix and<span class="math inline">\(^a{t}_b\)</span> is a translationvector.</p><h3 id="矩阵更新">矩阵更新</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">edVf.<span class="hljs-built_in">insert</span>(fMed.<span class="hljs-built_in">getRotationMatrix</span>().<span class="hljs-built_in">t</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>edVf.<span class="hljs-built_in">insert</span>(fMed.<span class="hljs-built_in">getRotationMatrix</span>().<span class="hljs-built_in">t</span>(), <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>TODO:这个没懂是干啥的，后面待补充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fMe = robot.<span class="hljs-built_in">get_fMe</span>();<br>vpPoseVector pose_error = <span class="hljs-built_in">static_cast</span>&lt;vpPoseVector&gt;(fMed.<span class="hljs-built_in">inverse</span>() * fMe);<br></code></pre></td></tr></table></figure><p>通过 <em>get_fMe()</em> 获取franka的姿态(Homogeneous transformationmatrix)，然后计算与目标位姿的误差，fMed是上面设置的目标位姿。<br />为什么 <em>fMed.inverse() * fMe</em>得到的就是位姿误差？这里我的理解是fMed的形式应该是<spanclass="math inline">\(^{B}T_{D}\)</span>(目标位姿相对基坐标系)，fMe的形式<spanclass="math inline">\({B}T_{E}\)</span>(末端执行器位姿相对基坐标系)，通过左乘变换矩阵将fMe转换到目标坐标系下，即末端执行器相对目标坐标系的位姿表示，得到的即是位姿误差。<br />//TODO:这里理解可能是错误的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vpMatrix La = symc::<span class="hljs-built_in">Ta</span>(pose_error);<br>Ja = La*edVf*fJe;<br><span class="hljs-keyword">if</span>(!symc::<span class="hljs-built_in">IsEqual</span>(sys_info.dt_, <span class="hljs-number">0</span>))&#123;<br>    Ja_dot = (Ja - Ja_old) / sys_info.dt_;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    Ja_dot = <span class="hljs-number">0</span>;<br>&#125;<br>Ja_old = Ja;<br></code></pre></td></tr></table></figure><p>通过 <em>Ta</em>函数输入的齐次变换矩阵（代表末端执行器位姿），计算李代数，李代数是用来表示变换群（如SO(3)和SE(3)）的无穷小变换（即微分形式）。返回的是6x6 的李代数矩阵，它表示了当前末端执行器位姿对应的微分变换。<br /><strong>它的作用是用于将6维的刚体运动（速度、力）从一个坐标系转换到另一个坐标系</strong><br />然后计算雅可比矩阵（Ja），<strong>注意fJe是上面获取的关节空间下的雅可比矩阵</strong>，通过左乘La*edVf将其转换到笛卡尔空间下，得到笛卡尔空间下的雅可比矩阵Ja。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Ja_pinv_B_t = (Ja * B.<span class="hljs-built_in">inverseByCholesky</span>()*Ja.<span class="hljs-built_in">t</span>()).<span class="hljs-built_in">inverseByCholesky</span>()*Ja*B.<span class="hljs-built_in">inverseByCholesky</span>();<br></code></pre></td></tr></table></figure></p><p>没看懂，根据chatgpt的说法，Ja_pinv_B_t是加权伪逆雅可比矩阵，其公式就是：<br /><span class="math display">\[Ja\_pinv\_B\_t=(Ja \cdot {B^{−1}}\cdotJa^{T})^{-1}\cdot Ja\cdot B^{-1}\]</span><br />贴一下它的解释：<br />这个表达式 Ja_pinv_B_t 是计算 加权伪逆雅可比矩阵的一种方式。加权伪逆（weightedpseudoinverse）是用于解决欠定或超定系统中的伪逆运算，其中矩阵不一定是方阵，且需要考虑特定权重。<br />伪逆雅可比矩阵在控制和运动学中用于求解欠定或冗余系统的逆运动学问题。在这种情况下，加权伪逆通过矩阵通过矩阵B引入了权重，使得解空间能够根据特定的权重进行优化。<br />加权伪逆的常见应用：<br />* 关节空间中的优化控制。<br />* 处理机器人冗余度时平衡关节的不同能量消耗或限制。<br />* 最小化在任务空间中实现运动时，关节空间中的力或速度。</p><p>该表达式通过Cholesky分解计算了加权伪逆雅可比矩阵。其目的是：<br />* 利用矩阵𝐵对雅可比矩阵进行加权，优化运动控制或冗余度处理。<br />* 使用Cholesky分解提升了计算效率，适用于正定对称矩阵𝐵的情境。</p><p>最终，Ja_pinv_B_t是雅可比矩阵的加权伪逆，它在机器人控制和运动学求解中用于优化和解决欠定或冗余问题。</p><h3 id="计算控制律">计算控制律</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x_error = <span class="hljs-built_in">static_cast</span>&lt;vpColVector&gt;(pose_error);<br>x_dot_error = La*edVf*(x_dot_desired - fJe*q_dot);<br></code></pre></td></tr></table></figure><p>在笛卡尔空间计算位置姿态误差和速度误差。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vpMatrix control_law = (-K*(x_error)+D*(x_dot_error)-Ja_dot*q_dot + x_dot_dot_desired);<br></code></pre></td></tr></table></figure> 通过阻抗控制计算控制律。<br />K项为刚度控制项，对位置误差施加恢复力，类似于弹簧的作用，推动机器人回到期望位置。<br />D项阻尼控制项，利用速度误差来增加阻尼，抑制振荡和不稳定行为。<br />-Ja_dot*q_dot雅可比矩阵的变化影响项，考虑了机器人关节速度和雅可比矩阵随时间变化的耦合效应。<br />x_dot_dot_desired期望加速度，直接给出系统应该达到的加速度目标。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tau_desired = B*Ja.<span class="hljs-built_in">pseudoInverse</span>()* control_law + C + F - (I7 - Ja.<span class="hljs-built_in">t</span>()*Ja_pinv_B_t)*B*q_dot*<span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure> 计算期望力矩，其公式为：<br /><span class="math display">\[\tau = M(q)\cdot \ddot{q} + C(q,\dot{q}) +F(\dot{q}) + G(q)\]</span><br />control_law左乘 <em>Ja.pseudoInverse()</em>是将control_law从笛卡尔空间转换到任务空间。<br />后面的-(I7 -Ja.t()*Ja_pinv_B_t)*B*q_dot*100根据chatgpt的解释是误差校正项，没看懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tau_cmd = tau_desired - tau0*std::<span class="hljs-built_in">exp</span>(-mu*sys_info.time_current_ - sys_info.time_start_trajectory_);<br>robot.<span class="hljs-built_in">setForceTorque</span>(vpRobot::JOINT_STATE, tau_cmd);<br></code></pre></td></tr></table></figure><p>计算真正的控制力矩tau_cmd，后面加上exp指数项是为了在启动时控制力矩是光滑的。</p>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rotation Matrix</title>
    <link href="/2024/09/05/Rotation-Matrix/"/>
    <url>/2024/09/05/Rotation-Matrix/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="性质和结论">性质和结论</h2><p><strong>从B frame相对于A frame的旋转矩阵的转置即为A frame相对于Bframe的旋转矩阵，同时等于其逆矩阵：</strong> <spanclass="math display">\[^{A}_{B}R = ^{B}_{A}A^{T}=^{B}_{A}A^{-1}\]</span><strong>旋转矩阵可以将一个点(P)从一个frame(B)变换到另一个frame(A)：</strong><span class="math display">\[^{A}P=^{A}_{B}R \cdot ^{B}P\]</span><strong>用坐标轴绕参考坐标系旋转角度来确定旋转矩阵：</strong> <spanclass="math display">\[R_{Z_{A}}({\theta})=\left[\begin{matrix}cos{\theta} &amp; -sin\theta &amp; 0 \\ sin{\theta} &amp; cos{\theta}&amp; 0 \\ 0 &amp; 0 &amp; 1 \end{matrix}\right]=\left[\begin{matrix}c{\theta} &amp; -s\theta &amp; 0 \\ s{\theta} &amp; c{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \end{matrix}\right]\]</span> <spanclass="math display">\[R_{X_{A}}({\theta})=\left[\begin{matrix} 1 &amp;0 &amp; 0 \\ 0 &amp; cos{\theta} &amp; -sin{\theta} \\ 0 &amp;sin{\theta} &amp; cos{\theta} \end{matrix}\right]=\left[\begin{matrix} 1&amp; 0 &amp; 0 \\ 0 &amp; c{\theta} &amp; -s{\theta} \\ 0 &amp;s{\theta} &amp; c{\theta} \end{matrix}\right]\]</span> <spanclass="math display">\[R_{Y_{A}}({\theta})=\left[\begin{matrix}cos{\theta} &amp; 0 &amp; sin{\theta} \\ 0 &amp; 1 &amp; 0 \\-sin{\theta} &amp; 0 &amp; cos{\theta}\end{matrix}\right]=\left[\begin{matrix} c{\theta} &amp; 0 &amp;s{\theta} \\ 0 &amp; 1 &amp; 0 \\ -s{\theta} &amp; 0 &amp; c{\theta}\end{matrix}\right]\]</span> <em>A表示Aframe，参考坐标系，即世界坐标系，B表示Bodyframe，本地坐标系，即物体坐标系。</em></p><p><strong>描述一个frame(B)相对另一个frame(A)的姿态：</strong> <spanclass="math display">\[^{A}_{B}R=\left[\begin{matrix} | &amp; | &amp; |\\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} \\ | &amp; | &amp; |\end{matrix}\right]\]</span> <em>其中<spanclass="math inline">\(^{A}X_{B}\)</span>，<spanclass="math inline">\(^{A}Y_{B}\)</span>，<spanclass="math inline">\(^{A}Z_{B}\)</span>分别代表B frame各坐标轴在Aframe投影的列向量。</em></p><h2 id="fixed-angles">Fixed Angles</h2><p><strong>针对空间中固定的坐标系XYZ进行旋转操作：</strong> <spanclass="math display">\[^{A}_{B}R_{XYZ}(\gamma,\beta,\alpha)=R_{Z}(\alpha)R_{Y}(\beta)R_{X}(\gamma)\]</span><span class="math display">\[=\left[\begin{matrix} c{\alpha} &amp;-s\alpha &amp; 0 \\ s{\alpha} &amp; c{\alpha} &amp; 0 \\ 0 &amp; 0 &amp;1 \end{matrix}\right]\left[\begin{matrix} c{\beta} &amp; 0 &amp;s{\beta} \\ 0 &amp; 1 &amp; 0 \\ -s{\beta} &amp; 0 &amp; c{\beta}\end{matrix}\right]\left[\begin{matrix} 1 &amp; 0 &amp; 0 \\ 0 &amp;c{\gamma} &amp; -s{\gamma} \\ 0 &amp; s{\gamma} &amp; c{\gamma}\end{matrix}\right]\]</span> <spanclass="math display">\[=\left[\begin{matrix}c{\alpha}c{\beta} &amp;c{\alpha}s{\beta}s{\gamma}-s{\alpha}c{\gamma} &amp;c{\alpha}s{\beta}c{\gamma}+s{\alpha}s{\gamma} \\ s{\alpha}c{\beta} &amp;s{\alpha}s{\beta}s{\gamma}+c{\alpha}c{\gamma} &amp;s{\alpha}s{\beta}c{\gamma}-c{\alpha}s{\gamma}  \\-s{\beta} &amp;c{\beta}s{\gamma} &amp;c{\beta}c{\gamma}\end{matrix}\right]=\left[\begin{matrix}r_{11} &amp;r_{12} &amp; r_{13} \\ r_{21} &amp; r_{22} &amp; r_{23} \\ r_{31} &amp;r_{32} &amp; r_{33}\end{matrix}\right]\]</span></p><p><em>先转的放在后面，转动的顺序（左乘）是不能互换的。</em></p><p><strong>通过R推算Angles：</strong> <spanclass="math display">\[^{A}_{B}R_{XYZ}(\gamma,\beta,\alpha)=\left[\begin{matrix}c{\alpha}c{\beta}&amp; c{\alpha}s{\beta}s{\gamma}-s{\alpha}c{\gamma} &amp;c{\alpha}s{\beta}c{\gamma}+s{\alpha}s{\gamma} \\ s{\alpha}c{\beta} &amp;s{\alpha}s{\beta}s{\gamma}+c{\alpha}c{\gamma} &amp;s{\alpha}s{\beta}c{\gamma}-c{\alpha}s{\gamma}  \\-s{\beta} &amp;c{\beta}s{\gamma} &amp;c{\beta}c{\gamma}\end{matrix}\right]=\left[\begin{matrix}r_{11} &amp;r_{12} &amp; r_{13} \\ r_{21} &amp; r_{22} &amp; r_{23} \\ r_{31} &amp;r_{32} &amp; r_{33}\end{matrix}\right]\]</span> <spanclass="math inline">\(if\space{\beta} \neq 90^{\circ}\)</span> <spanclass="math display">\[\beta=Atan2(-r_{31},\sqrt{r_{11}^2+r_{21}^2})\]</span><spanclass="math display">\[\alpha=Atan2(\frac{r_{21}}{c{\beta}},\frac{r_{11}}{c{\beta}})\]</span><spanclass="math display">\[\gamma=Atan2(\frac{r_{32}}{c{\beta}},\frac{r_{33}}{c{\beta}})\]</span><span class="math inline">\(if \space \beta=90^{\circ}\)</span> <spanclass="math display">\[\alpha=0^{\circ}\]</span> <spanclass="math display">\[\gamma=Atan2(r_{12},r_{22})\]</span> <spanclass="math inline">\(if \space \beta=-90^{\circ}\)</span> <spanclass="math display">\[\alpha=0^{\circ}\]</span> <spanclass="math display">\[\gamma=-Atan2(r_{12},r_{22})\]</span></p><h2 id="euler-angles">Euler Angles</h2><p><strong>Z-Y-X</strong> <spanclass="math display">\[^{A}_{B}R_{Z^{&#39;}Y^{&#39;}X^{&#39;}}(\alpha,\beta,\gamma)=^{A}_{B^{&#39;}}R^{B^{&#39;}}_{B^{&#39;&#39;}}R^{B^{&#39;&#39;}}_{B}R=R_{Z^{&#39;}}(\alpha)R_{Y^{&#39;}}(\beta)R_{X^{&#39;}}(\gamma)\]</span><em>先转的放在前面，转动的顺序（左乘）是不能互换的。</em> <em>对FixedAngle以XYZ的顺序转动，相当于对Euler Angle以ZYX的顺序转动。</em><em>Euler Angle的正转和Fixed Angle的反转会得到相同的解。</em></p><h2 id="刚体状态的表达">刚体状态的表达</h2><p><strong>Homogeneous transformation matrix (4x4):</strong> <spanclass="math display">\[^{A}_{B}T=\left[\begin{matrix}^{A}_{B}R_{3\times3}&amp; ^{A}P_{B_{org}3\times1} \\ 0_{1\times3} &amp;1\end{matrix}\right]\]</span> <spanclass="math display">\[=\left[\begin{matrix} | &amp; | &amp; | &amp; |\\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} &amp; P_{B_{org}} \\ |&amp; | &amp; | &amp; | \\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span><em>左上角为旋转矩阵，右上角为移动状态。</em></p><p><strong>移动和转动复合运算：</strong> <spanclass="math display">\[^{A}P_{3\times1}=^{A}_{B}R^{B}P_{3\times1}+^{A}P_{B_{org}3\times1}\]</span><span class="math display">\[\left[\begin{matrix}^{A}P \\1\end{matrix}\right]=^{A}_{B}T\left[\begin{matrix}^{B}P \\1\end{matrix}\right]\]</span></p><p><strong>可连续操作：</strong> <spanclass="math display">\[^{A}_{B}T=^{A}_{C}T^{C}_{D}T^{D}_{B}T\]</span><em>"sequential transformation"</em></p><p><strong>Mapping and Operator:</strong></p><p>transformationmatrix既有Mapping（把向量从一个frame转换到另一个frame下来看）的功能也可当作Operator对向量（或点）进行移动或旋转（在同一个frame）。</p><p><span class="math display">\[\left[\begin{matrix}^{A}P_2 \\1\end{matrix}\right]=T\left[\begin{matrix}^{A}P_1 \\1\end{matrix}\right]\]</span></p><h2 id="homogeneous-transformation-matrix的三种用法">Homogeneoustransformation matrix的三种用法</h2><ol type="1"><li>描述一个frame（相对于另一个frame）的空间状态。 <spanclass="math display">\[^{A}_{B}T=\left[\begin{matrix} | &amp; | &amp; |&amp; | \\ ^{A}X_{B} &amp; ^{A}Y_{B} &amp; ^{A}Z_{B} &amp; P_{B_{org}}\\ | &amp; | &amp; | &amp; | \\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></li><li>将point由某一个frame的表达转换到另一个frame来表达。 <spanclass="math display">\[\left[\begin{matrix}^{A}P \\1\end{matrix}\right]=^{A}_{B}T\left[\begin{matrix}^{B}P \\1\end{matrix}\right]\]</span></li><li>将point(vector)在同一个frame中进行移动和转动。 <spanclass="math display">\[\left[\begin{matrix}^{A}P_2 \\1\end{matrix}\right]=T\left[\begin{matrix}^{A}P_1 \\1\end{matrix}\right]\]</span></li></ol><h2 id="transformation-matrix运算">Transformation Matrix运算</h2><p><strong>逆矩阵：</strong></p><p><spanclass="math display">\[^{A}_{B}T^{B}_{A}T=^{A}_{B}T^{A}_{B}T^{-1}=I_{4\times4}\]</span></p><p><spanclass="math display">\[^{A}_{B}T^{-1}=\left[\begin{matrix}^{A}_{B}R^{T}&amp; -^{A}_{B}{R^{T}}^{A}P_{B_{org}} \\ 0_{1\times3} &amp;1\end{matrix}\right]\]</span> <strong>连续运算法则：</strong></p><ol type="1"><li>{B}对{A}的转轴旋转：用"premultiply"，先转的放在后面</li><li>{B}对{B}自身的转轴旋转：用"postmultiply"，先转的放在前面</li></ol><h2 id="links">links</h2><p><a href="https://www.coursera.org/learn/robotics1">機器人學一(Robotics (1))</a></p>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CLF-CBF</title>
    <link href="/2024/09/04/CLF-CBF/"/>
    <url>/2024/09/04/CLF-CBF/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2id="动态控制仿射系统dynamics-control-affine-system">1.动态控制仿射系统(DynamicsControl Affine System)</h2><p>对于<span class="math inline">\(\dot{x} =F(t,x,u)\)</span>，其中系统状态<spanclass="math inline">\(x\in{\mathbb{R}^n}\)</span>，系统输入<spanclass="math inline">\(u \in{\mathbb{R}^m}\)</span>，如果<spanclass="math inline">\(F\)</span>对于<spanclass="math inline">\(x\)</span>和<spanclass="math inline">\(u\)</span>是Lipschitz连续的，时间<spanclass="math inline">\(t\)</span>是piecewise连续的，那么在给定的初始条件<spanclass="math inline">\(x_0\)</span>下，轨迹<spanclass="math inline">\(x(t)\)</span>是存在并且unique的。</p><p>一般写成如下形式：</p><p><span class="math display">\[\dot{x} = f(x) + g(x)u\]</span></p><p>其中<spanclass="math inline">\(f:\mathbb{R}^n\rightarrow{\mathbb{R}^n},g:\mathbb{R}^n\rightarrow{\mathbb{R}^{n*m}}\)</span>，<spanclass="math inline">\(x\)</span>是Lipschitz连续，<spanclass="math inline">\(x_e = 0\)</span>。</p><h2 id="clfcontrol-lyapunov-function">2.CLF(Control LyapunovFunction)</h2><p>Lyapunove Function数学定义如下：</p><p><span class="math display">\[V(x)\]</span> <spanclass="math display">\[s.t. V(x_e) = 0, V(x) &gt; 0 \ for \ x \neqx_e\]</span> <span class="math display">\[\dot{V(x)} = \frac{\partialV}{\partial x}f(x) &lt; 0 \ for \ x \neq x_e\]</span></p><p><spanclass="math inline">\(V(x)\)</span>是定义的Lyapunov函数，下面的是约束条件，当满足上述两个约束时，我们可以认为x渐近稳定。</p><p>将输入<span class="math inline">\(u\)</span>引入到LyapunoveFunction，得到新的方程。 使<spanclass="math inline">\(V(x):\mathbb{R}^n\rightarrow{\mathbb{R}}\)</span>是连续Differential函数，如果存在一个常数<spanclass="math inline">\(c&gt;0\)</span>使得<spanclass="math inline">\(V(x)\)</span>满足如下条件，那么<spanclass="math inline">\(V(x)\)</span>就是一个关于<spanclass="math inline">\(x\)</span>的Control Lyapunov Function。</p><p><span class="math inline">\(1)\ \Omega := \{x\in{\mathbb{R}^n}:V(x)\le{c}\}\)</span>，<spanclass="math inline">\(V(x)\)</span>是有界的</p><p><span class="math inline">\(2)\ V(x)&gt;0\)</span>，对于所有的<spanclass="math inline">\(s\in{R^n}\backslash \{x_e\}\)</span>，<spanclass="math inline">\(V(e_e)=0\)</span></p><p><span class="math inline">\(3)\inf_{u\in{U}}\dot{V}(x,u)&lt;0\)</span>，对于所有的<spanclass="math inline">\(x\in{\Omega_c}\backslash\{x_e\}\)</span></p><p>为了简化<spanclass="math inline">\(\dot{V}(x,u)\)</span>的表达，用Lie括号描述：</p><p><span class="math display">\[\dot{V}(x,u) = \nabla{V}(x) * \dot{x} =\nabla{V}(x) * f(x) + \nabla{V}(x) * g(x)*u = L_fV(x) +L_gV(x)u\]</span> <spanclass="math display">\[(L_pq(x):=\nabla{q(x)}*p(x))\]</span></p><p>CLF保证系统最终会稳定，但不能确定多快才能稳定，这时候引入指数稳定CLF(ESCLF)。</p><p>如果存在常数<span class="math inline">\(\lambda &gt;0\)</span>使得<span class="math inline">\(inf_{u\in{U}}\dot{V}(x,u)+{\lambda}{V(x)}\le0\)</span> ，那么<spanclass="math inline">\(V(x)\)</span>就是ESCLF。</p><p><img src="/img/CLF-CBF/ESCLF.png" /></p><h2 id="clf-qp">3.CLF-QP</h2><p>将CLF转化为QP问题，搜索满足CLF-QP问题的输入u。</p><p><span class="math display">\[argmin\  (u-u_ref)^{T}{H(u-u_ref)}+p\delta^2\]</span> <spanclass="math display">\[subject\ to :\L_fV(x)+L_gV(x)u+\lambda{V(x)}\le{\delta}\]</span></p><p>其中<span class="math inline">\(\delta\)</span>是松弛变量，<spanclass="math inline">\(p\)</span>是惩罚因子，设置松弛变量的目的是在实际搜索中，较难找到一个合适的解，增加松弛变量后会放松CLF条件，在允许的情况下不满足CLF约束，但获得一个解。</p><p>另外，这里的H是Hassian矩阵，表示二次项系数，将<spanclass="math inline">\((u-u_ref)^{T}{H(u-u_ref)}\)</span>理解为二次的cost函数(或者能量函数？)，是人为构建的，二次保证解的u的输入使系统收敛较快。</p><h2 id="cbf">4.CBF</h2><p>CLF约束确保系统渐趋稳定，而CBF的作用是确保系统安全，使系统处于规定的安全集合约束内。</p><pre><code class="hljs">//TODO:补充CBF原理</code></pre><p>当<span class="math inline">\(B(x):\mathbb{R}^n \rightarrow\mathbb{R}\)</span>是连续可微的，零超水平集(zero-superlevel)为<spanclass="math inline">\(C\)</span>，<spanclass="math inline">\(C=\{x|B(x)\ge0\}\)</span>，对于所有<spanclass="math inline">\(x\in{\partial{C}}\)</span>，<spanclass="math inline">\(\nabla{B(x)\ne0}\)</span>，如果存在一个扩展<spanclass="math inline">\(Class \ K_\infty\)</span>函数<spanclass="math inline">\(\alpha\)</span>（工程中一般使用正常数和<spanclass="math inline">\(B(x)\)</span>的线性组合获取，如：<spanclass="math inline">\(\gamma{B(x)},\gamma&gt;0\)</span>），存在一个集合<spanclass="math inline">\(D\subset{\mathbb{R}^n}\)</span>，使得<spanclass="math inline">\(C\subset{D}\)</span>满足：</p><p><spanclass="math display">\[sup_{u\in{U}}[L_f{B(x)}+L_g{B(x)}u]+\alpha({B(x)})\ge0\]</span></p><p>那么对于所有<span class="math inline">\(x\in{D}\)</span>，<spanclass="math inline">\(B(x)\)</span>是一个CBF。</p><p><img src="/img/CLF-CBF/CBF.png" /></p><h2 id="clf-cbf-qp">5.CLF-CBF-QP</h2><p>将CLF和CBF都转化为QP问题的约束条件，其中CLF保证控制器稳定，CBF保证控制满足安全条件。</p><p><span class="math display">\[argmin\  (u-u_ref)^{T}{H(u-u_ref)}+p\delta^2\]</span> <spanclass="math display">\[subject\ to :\]</span> <spanclass="math display">\[\L_fV(x)+L_gV(x)u+\lambda{V(x)}\le{\delta}\]</span> <spanclass="math display">\[L_f{B(x)}+L_g{B(x)}u]+\gamma{B(x)}\ge0\]</span></p><h2 id="links">links</h2><ul><li><em><ahref="https://zhuanlan.zhihu.com/p/568328445">根据自适应巡航系统(ACC)来理解CBF(ControlBarrier Function)-入门知识</a></em><br /></li><li><em><a href="https://zhuanlan.zhihu.com/p/277326421">CLF-CBFController</a></em><br /></li><li><em><ahref="https://github.com/HybridRobotics/CBF-CLF-Helper">HybridRobotics/CBF-CLF-Helper</a></em><br /></li><li><em><a href="https://www.youtube.com/watch?v=_Tkn_Hzo4AA">Jason Choi-- Introduction to Control Lyapunov Functions and Control BarrierFunctions</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反步控制</title>
    <link href="/2024/09/04/%E5%8F%8D%E6%AD%A5%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/09/04/%E5%8F%8D%E6%AD%A5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="物理模型">1.1 物理模型</h2><p>令期望轨迹为<span class="math inline">\(sint\)</span>曲线：<br /><span class="math display">\[x_d = \sin{t}\]</span> <spanclass="math display">\[\dot{x_d} = \cos{t}\]</span></p><p>写出状态方程：<br /><span class="math display">\[\dot{x_1} = x_2 + f_1(x_1)\]</span> <spanclass="math display">\[\dot{x_2} = u + f_2(x_1,x_2) = u + \frac{(M * g *l)}{J} * \sin{x_1} - \frac{D}{J} * x_2\]</span></p><p><span class="math display">\[f_1(x_1) = 0\]</span> <spanclass="math display">\[f_2(x_1,x_2) = \frac{(M * g * l)}{J} * \sin{x_1}- \frac{D}{J} * x_2\]</span>其中第一项为重力对系统的影响，第二项为摩擦力对系统的影响。</p><p><em>其中M为质量，g为重力加速度，l为臂长，J为转动惯量，D为阻尼系数。</em><em><span class="math inline">\(\dot{x_1}\)</span>为角速度，<spanclass="math inline">\(\dot{x_2}\)</span>为角加速度，<spanclass="math inline">\(x_1\)</span>为角度，<spanclass="math inline">\(x_2\)</span>为角速度。</em></p><h2 id="知识补充">1.2 知识补充</h2><p>力矩<span class="math inline">\(M = |F| * |r| *\sin{\varphi}\)</span>力矩除以转动惯量可以描述一个物体收到的外部力矩对其角加速度的影响。阻尼系数除以转动惯量乘以角速度描述了在转动运动中由阻尼产生的转动摩擦力的效应。这个物理量通常被称为阻尼比。</p><p><em>*部分解释来自chatgpt</em></p><h2 id="反步控制">2.1 反步控制</h2><p>构造误差 <span class="math display">\[e_1 = x_1 - x_d\]</span> <spanclass="math display">\[e_2 = x_2 - \alpha_1\]</span> 其中<spanclass="math inline">\(\alpha_1\)</span>为虚拟控制律，即中间状态的控制量。</p><p>构造Lyapunov函数 <span class="math display">\[V_1 =\frac{1}{2}{e_1}^2\]</span> <span class="math display">\[V_2 =\frac{1}{2}{e_1}^2 + \frac{1}{2}{e_2}^2\]</span></p><p>由Lyapunov方法可知，需令<spanclass="math inline">\(\dot{V_1}\)</span> ,<spanclass="math inline">\(\dot{V_2}\)</span>负定使得系统渐趋稳定。</p><p><span class="math display">\[\dot{V_1} = {e_1}\dot{e_1} ={e_1}(\dot{x_1} - \dot{x_d}) = {e_1}(x_2 + f_1(x_1) -\cos{t})\]</span></p><p>故令<span class="math inline">\(\alpha_1 = \cos{t} - e_1 -f_1(x_1)\)</span>，注意此时<spanclass="math inline">\(\alpha_1\)</span>为虚拟控制律，<spanclass="math inline">\(x_2\)</span>为实际控制</p><p><span class="math display">\[\dot{V_1} = {e_1}\dot{e_1} ={e_1}(\dot{x_1} - \dot{x_d})\]</span> <span class="math display">\[ ={e_1}(x_2 + f_1(x_1) - \cos{t}) = {e_1}(e_2 + \alpha_1 + f_1(x_1) -\cos{t}) = {e_1}(e_2 - e_1)\]</span></p><p><span class="math display">\[\dot{e_2} = \dot{x_2} - \dot{\alpha_1} =u + f_2(x_1,x_2) - \dot{\alpha_1}\]</span></p><p><span class="math display">\[\dot{V_2} = e_1(e_2 - e_1) +{e_2}\dot{e_2} = -{e_1}^2 + {e_2}({e_1} + \dot{e_2})\]</span></p><p>需令<span class="math inline">\(\dot{V_2}\)</span>负定，令<spanclass="math inline">\(e_1 + \dot{e_2} = -e_2\)</span>即可，此时<spanclass="math inline">\(\dot{V_2} = -{e_1}^2 - {e_2}^2\)</span>负定 代入得<span class="math inline">\(e_1 + u + f_2(x_1,x_2) - \alpha_1 =-e_2\)</span> 得到最终控制量<span class="math inline">\(u = -e_1 - e_2 -f_2(x_1,x_2) + \dot{\alpha_1}\)</span></p><p>上面得到 <span class="math display">\[f_1(x_1) = 0\]</span> <spanclass="math display">\[f_2(x_1,x_2) = \frac{(M * g * l)}{J} * \sin{x_1}- \frac{D}{J} * x_2\]</span></p><p>所以<span class="math display">\[u = -e_1 - e_2 + \dot{\alpha_1} -(\frac{(M * g * l)}{J} * \sin{x_1} - \frac{D}{J} * x_2)\]</span></p><h2 id="links">links</h2><ul><li><em><ahref="https://haosutopia.github.io/2018/01/Backstepping-01/">Backstepping（反步控制）</a></em></li><li><em><ahref="https://zh.wikipedia.org/wiki/%E5%8F%8D%E6%8E%A8%E6%8E%A7%E5%88%B6">wiki反推控制</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>裂痕</title>
    <link href="/2024/09/03/%E8%A3%82%E7%97%95/"/>
    <url>/2024/09/03/%E8%A3%82%E7%97%95/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><center>裂痕</center><center>边缘纹路生长，</center><center>哭泣的笑容，</center><center>过去的完整再无有几分存在。</center><center>爱或未来，</center><center>自甘地遗忘。</center><center>燃烧一盎司灵魂也无法弥补这急转隔断，</center><center>都不足一千公里的时间长。</center><center>笨拙的花张口结舌，</center><center>眼泪流淌。</center><center>几缕薄影倏忽而过，</center><center>哀荣四泻。</center><center>破碎，</center><center>月和目光。</center><center>源头是廉价的情感理想，</center><center>尾流入地海。</center><center>二到一到二，</center><center>无到有到无。</center><center>过度或翼翼滋生裂隙，</center><center>自产怒火惊雷，</center><center>静静撕咬。</center><center>曾是永远完整永远一起，</center><center>无有输赢，</center><center>而今却是谢幕时光。</center><center>痛苦急速转换，</center><center>一道无形的裂痕悄然而生，</center><center>自此疾驰。</center><center>幻想和秋风，</center><center>由我亲手斩断，</center><center>显现的裂痕，</center><center>存于你我各自世界之间</center>]]></content>
    
    
    <categories>
      
      <category>发电</category>
      
    </categories>
    
    
    <tags>
      
      <tag>poem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
